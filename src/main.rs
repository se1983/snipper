use std::error::Error;
use std::time::Duration;

use clap::Clap;
use reqwest::{Client, header};
use serde::{Deserialize, Serialize};
use serde_json::json;


#[derive(Clap, Debug, Clone)]
pub struct Opts {
    pub token: String,
    pub mode: String,
    pub url: String,
    #[clap(long)]
    pub id: Option<usize>,
    #[clap(long)]
    pub title: Option<String>,
    #[clap(long)]
    pub file_path: Option<String>,
    pub file_content: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct File {
    path: String,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct SnippetResponse {
    pub(crate) id: usize,
    file_name: String,
    files: Vec<File>,
    web_url: String,
}

fn create_client(config: &Opts) -> Result<Client, Box<dyn Error>, > {
    let mut headers = header::HeaderMap::new();
    let mut access_token = header::HeaderValue::from_str(
        config.token.as_str()
    )?;
    access_token.set_sensitive(true);
    headers.insert("PRIVATE-TOKEN", access_token);
    headers.insert(
        "Content-Type",
        header::HeaderValue::from_static("application/json"),
    );

    let client = Client::builder()
        .user_agent("AWSME Snipper")
        .default_headers(headers)
        .timeout(Duration::from_secs(10))
        .build()?;
    Ok(client)
}


async fn do_post(client: Client, config: Opts) -> Result<SnippetResponse, Box<dyn Error>> {
    let body = json!({
                "title": config.title.unwrap(),
                "description": "Autogenerated snippet",
                "visibility": "internal",
                "files": [{
            "file_path": "init.txt",
            "content": &chrono::offset::Local::now().to_string()
        }],

    });

    let resp = client
        .post(&config.url)
        .json(&body)
        .send()
        .await?;

    if !resp.status().is_success(){
        panic!("{}", resp.text().await.unwrap())
    }

    let data = resp.json().await?;
    println!("{:?}", data);
    Ok(data)
}

async fn do_put(client: Client, config: Opts) -> Result<SnippetResponse, Box<dyn Error>> {
    let body = json!({
                "files": [{
            "file_path": config.file_path.as_ref().unwrap(),
            "content": config.file_content.as_ref().unwrap(),
            "action": "create",
        }],

    });

    let url = format!("{}{}", config.url, config.id.unwrap());

    let resp = client
        .put(url)
        .json(&body)
        .send()
        .await?;

    if !resp.status().is_success(){
        panic!("{}", resp.text().await.unwrap())
    }
    Ok(resp.json().await?)
}


#[tokio::main]
async fn main() {
    let config: Opts = Opts::parse();
    let client = create_client(&config).unwrap();

    let resp = match config.mode.as_str() {
        "Create" => do_post(client, config)
            .await
            .unwrap_or_else(|err| panic!("Could not create the Snippet: [{}]", err)),
        "Update" => do_put(client, config)
                .await
                .unwrap_or_else(|err| panic!("Could not update the Snippet: [{}]", err)),
        _ => panic!("mode not accepted!")
    };


    let response_text = serde_json::to_string_pretty(&resp).unwrap();
    println!("{}", response_text);
}


