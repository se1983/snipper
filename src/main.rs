use std::error::Error;
use std::time::Duration;

use clap::Clap;
use reqwest::{Client, header};
use serde::{Deserialize, Serialize};
use serde_json::json;

#[derive(Clap, Debug, Clone)]
pub struct Opts {
    #[clap(long)]
    pub mode: String,
    #[clap(long)]
    pub title: String,
    #[clap(long)]
    pub file_path: Option<String>,
    pub url: String,
    pub token: String,
    pub file_content: Option<String>,

}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct File {
    path: String,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct Snippet {
    title: String,
    id: usize,
    file_name: String,
    files: Vec<File>,
    web_url: String,
}


fn create_client(config: &Opts) -> Result<Client, Box<dyn Error>, > {
    let mut headers = header::HeaderMap::new();
    let mut access_token = header::HeaderValue::from_str(
        config.token.as_str()
    )?;
    access_token.set_sensitive(true);
    headers.insert("PRIVATE-TOKEN", access_token);
    headers.insert(
        "Content-Type",
        header::HeaderValue::from_static("application/json"),
    );

    let client = Client::builder()
        .user_agent("AWSME Snipper")
        .default_headers(headers)
        .timeout(Duration::from_secs(10))
        .build()?;
    Ok(client)
}


async fn get_snippet(client: &Client, config: &Opts) -> Result<Option<Snippet>, Box<dyn Error>> {
    let resp = client.get(&config.url).send().await?;
    if !resp.status().is_success() {
        panic!("{}", resp.text().await.unwrap())
    }
    let data: Vec<Snippet> = resp.json().await?;
    let snip = data.into_iter().filter(|s| s.title == config.title).next();
    Ok(snip)
}

async fn create_snippet(client: &Client, config: &Opts) -> Result<Snippet, Box<dyn Error>> {
    let body = json!({
                "title": config.title,
                "description": "Autogenerated snippet",
                "visibility": "internal",
                "files": [{
            "file_path": "init.txt",
            "content": &chrono::offset::Local::now().to_string()
        }],

    });

    let resp = client
        .post(&config.url)
        .json(&body)
        .send()
        .await?;
    if !resp.status().is_success() {
        panic!("{}", resp.text().await.unwrap())
    }

    let data = resp.json().await?;
    Ok(data)
}

async fn do_put(client: &Client, config: &Opts, id: &usize) -> Result<Snippet, Box<dyn Error>> {
    let body = json!({
            "files": [{
                "file_path": config.file_path.as_ref().unwrap(),
                "content": config.file_content.as_ref().unwrap(),
                "action": "create",
        }],

    });
    let url = format!("{}{}", config.url, id);

    let resp = client
        .put(url)
        .json(&body)
        .send()
        .await?;

    if !resp.status().is_success() {
        panic!("{}", resp.text().await.unwrap())
    }
    Ok(resp.json().await?)
}


#[tokio::main]
async fn main() {
    let config: Opts = Opts::parse();
    let client = create_client(&config).unwrap();

    let resp = match config.mode.as_str() {
        "Create" => {
            match get_snippet(&client, &config).await.unwrap() {
                Some(snippet) => snippet,
                None => create_snippet(&client, &config)
                    .await
                    .unwrap_or_else(|err| panic!("Error creating the Snippet: [{}]", err))
            }
        }
        "Update" => {
            let snip =  get_snippet(&client, &config).await
                .unwrap_or_else(|err| panic!("Error getting the snippet: {}", err))
                .unwrap_or_else(|| panic!("Could not find snippet."));
            do_put(&client, &config, &snip.id)
                .await
                .unwrap_or_else(|err| panic!("Error updating the Snippet: [{}]", err))
        },
        "Get" => {
            get_snippet(&client, &config).await
                .unwrap_or_else(|err| panic!("Error getting the snippet: {}", err))
                .unwrap_or_else(|| panic!("Could not find snippet."))
        }
        _ => panic!("mode '{}' not accepted!", &config.mode)
    };
    let response_text = serde_json::to_string_pretty(&resp).unwrap();
    println!("{}", response_text);
}


